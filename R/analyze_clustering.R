#' This function analyzes ST data based on clustering generated by cluster_counts_OL. 
#' It calculates a list of genes specific to a certain cluster and identifies differentually expressed genes
#' across clusters
#'
#' @param counts non-negative numeric matrix containing gene counts, 
#' rows correspond to spots, columns correspond to genes
#' @param ids data frame or matrix assigning spatial coordinates to the spots (see process_input() for details)
#' @param clustering list containing clustering information as returned by cluster_counts_OL (numeric vector assigning spots to clusters)
#' @param sig.level significance level for the t-test between clusters; genes with p-values above this threshold
#' will be removed from output
#' @return list with 3 entries:\cr
#' 1) specific - character vecor containing names of genes that are specific to any cluster\cr
#' 2) differential genes - data frame containing information (name, ckuster, p-value, up-/downregulation) for differentially expressed genes\cr
#' 3) dsg - differential genes reduced to genes that are also contained in 'specific'
#' @export
analyze_clustering <- function(counts, ids, clustering, sig.level = 0.05){
    #counts <- counts[rownames(clustering.info$scores),]
    #clustering <- clustering.info$clustering

    # find cluster-specific genes by calculating total RNA per cluster and gene
    cluster.libs <- matrix(0, ncol=ncol(counts), nrow = length(unique(clustering)))
    colnames(cluster.libs) <- colnames(counts)
    rownames(cluster.libs) <- unique(clustering)

    for(cl in rownames(cluster.libs)){
        cluster.libs[cl,] <- colSums(counts[which(clustering == as.numeric(cl)),,drop=F])
    }
    # reduce to genes that are not 0 overall
    cluster.libs <- cluster.libs[, which(colSums(cluster.libs) > 0)]
    # scale to 1
    cluster.libs <- apply(cluster.libs, 2, function(x){x / sum(x)}) 

    # create entropy vector (entropy for each spot)
    specific <- sapply(colnames(cluster.libs), function(x){
        if(! sum(cluster.libs[,x]) > 0) return(NA)
        if(any(cluster.libs[,x] == 0)){
            entropy <- -sum(cluster.libs[-which(cluster.libs[,x] == 0), x] * log2(cluster.libs[-which(cluster.libs[,x] == 0), x]))
        }else{
            entropy <- -sum(cluster.libs[, x] * log2(cluster.libs[, x]))
        }
        return(entropy)
    })

    names(specific) <- colnames(cluster.libs)
    if(any(is.na(specific))){
    	specific <- specific[-which(is.na(specific))]
    }
    specific <- specific[which(specific <= summary(specific)[2])]
   
    # implement testing with multtest for differentially expressed genes for each cluster
    # test each cluster against all other clusters at the same time
    test.results <- list()
    for(cl in rownames(cluster.libs)){
        # create temporary count matrix (transposed for multtest) and class labels
	temp.counts <- t(counts[c(which(clustering == cl),which(clustering != cl)),])
        labs <- c(rep(0,length(which(clustering == cl))), rep(1,length(which(clustering != cl))))
	# calculate t-scores, p-values and adjust
        t.scores <- mt.teststat(temp.counts, labs, test = "t")
        p.vals <- 2 * pt(abs(t.scores), length(labs) - 2, lower.tail = FALSE)
        p.vals <- p.adjust(p.vals, method = "BH")
        names(p.vals) <- rownames(temp.counts)

	# if test not possible. set the genes p-value to 1 (max)
	if(any(is.na(p.vals))){
		p.vals[is.na(p.vals)] <- 1
	}
	if(any(is.nan(p.vals))){
		p.vals[is.nan(p.vals)] <- 1
	}

	p.vals <- sort(p.vals)
        test.results[[cl]] <- p.vals
    }

    # right now all.genes is actually all genes, but if a significance cutoff
    # were used above, this would be needed
    all.genes <- as.vector(sapply(test.results, function(x){names(x)}))
    all.genes <- all.genes[!is.na(all.genes)]
    all.genes <- unique(all.genes)

    # sort the clustering vector to have consistent order
    clusters <- sort(unique(clustering))
    # create a table with genes' p-value per cluster
    gene.table <- c()
    for(g in all.genes){
        cluster.values <- c()
        for(cl in clusters){
	    # if the gene is present in test results for the cluster add the value
	    # else add 1
            if(g %in% names(test.results[[cl]])){
                cluster.values <- c(cluster.values, as.numeric(test.results[[cl]][g]))
            }else{
                cluster.values <- c(cluster.values, 1)
            }
        }
        gene.table <- rbind(gene.table, cluster.values)
    }
    # create data frame with correct row- and colnames
    gene.table <- as.data.frame(gene.table)
    colnames(gene.table) <- clusters
    rownames(gene.table) <- all.genes
    for(cl in colnames(gene.table)){
	    gene.table[[cl]] <- as.numeric(as.character(gene.table[[cl]]))
    }

    # remove genes above significance threshold / with p-value NA in any cluster
    to.remove <- c()
    for(i in 1:nrow(gene.table)){
        if(min(gene.table[i,]) > sig.level | is.na(min(gene.table[i,]))){
            to.remove <- c(to.remove, i)
        }
    }
    if(length(to.remove) > 0){
        gene.table <- gene.table[-to.remove,]
    }
    # order table by minimum p-value for each gene
    gene.table <- gene.table[order(apply(as.matrix(gene.table), 1, min)),]
   
    # reduced information to minimum p-value, corresponding cluster, gene name and up/downregulation info
    gene.info <- c()
    for(i in 1:nrow(gene.table)){
        g <- rownames(gene.table)[i]
        p <- min(gene.table[i,])
        cl <- clusters[which.min(gene.table[i,])]
	if(length(cl) > 0){
		# up-/downregulation
        	reg <- sign(mean(counts[which(clustering == cl),g]) - mean(counts[which(clustering != cl), g]))
        	gene.info <- rbind(gene.info,
                	           c(g, cl, p, reg))
	}
    }
    gene.info <- as.data.frame(gene.info)
    colnames(gene.info) <- c("gene", "cluster", "pVal", "regulation")
    gene.info$pVal <- as.numeric(as.character(gene.info$pVal))
    gene.info$regulation <- as.numeric(as.character(gene.info$regulation))
    rownames(gene.info) <- as.character(gene.info$gene)

    return(list(
	specific_genes = names(specific), 
	differential_genes = gene.info, 
	dsg = gene.info[which(rownames(gene.info) %in% names(specific)),]
	))
}
