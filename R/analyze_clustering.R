#' This function analyzes ST data based on clustering generated by cluster_counts_OL. 
#' It calculates a list of genes specific to a certain cluster and identifies differentually expressed genes
#' across clusters
#'
#' @param counts non-negative numeric matrix containing gene counts, 
#' rows correspond to spots, columns correspond to genes
#' @param ids data frame or matrix assigning spatial coordinates to the spots (see process_input() for details)
#' @param clustering list containing clustering information as returned by cluster_counts_OL (numeric vector assigning spots to clusters)
#' @param sig.level significance level for the t-test between clusters; genes with p-values above this threshold
#' will be removed from output; default 0.05
#' @param lasso.data output of build_lassos function
#' @param deg.weight
#' @param lls.weight
#' @param entropy.weight
#' @param build.lasso
#' @param gamma
#' @param ncores
#' @param normalize default FALSE
#' @return list with 2 entries:\cr
#' 1) differential genes - data frame containing information (name, ckuster, p-value, up-/downregulation) for differentially expressed genes. Ordered by gene rank.\cr
#' 2) gene.cluster.table - data frame containing for each gene in differential.genes the p-value for differential expression in each cluster
#' @export

analyze_clustering <- function(counts, ids, clustering, sig.level = 0.001, lasso.data = NULL, deg.weight = 2, lls.weight = 3, entropy.weight = 1, build.lasso = FALSE, gamma = 3, ncores = 4, normalize = FALSE){
    cat("calculating gene-wise entropy...\t")
    # find cluster-specific genes by calculating total RNA per cluster and gene

    if(is.null(lasso.data)){
    cluster.libs <- matrix(0, ncol=ncol(counts), nrow = length(unique(clustering)))
    colnames(cluster.libs) <- colnames(counts)
    rownames(cluster.libs) <- unique(clustering)

    for(cl in rownames(cluster.libs)){
        cluster.libs[cl,] <- colSums(counts[which(clustering == as.numeric(cl)),,drop=F])
    }
    }else{
    cluster.libs <- matrix(0, ncol=ncol(lasso.data$counts), nrow = length(unique(clustering)))
    colnames(cluster.libs) <- colnames(lasso.data$counts)
    rownames(cluster.libs) <- unique(clustering)



    for(cl in rownames(cluster.libs)){
	names(clustering) <- rownames(counts)
        cluster.libs[cl,] <- colSums(lasso.data$counts[which(clustering[rownames(lasso.data$counts)] == as.numeric(cl)),,drop=F])
    }
 
    }

    # cannot handle negative expression for entropy
    if(any(cluster.libs < 0)){
	    cluster.libs <- cluster.libs - min(cluster.libs)
    }
    # reduce to genes that are not 0 overall
    cluster.libs <- cluster.libs[, which(colSums(cluster.libs) > 0)]
    # scale to 1
    cluster.libs <- apply(cluster.libs, 2, function(x){x / sum(x)}) 

    # create entropy vector (entropy for each spot)
    specific <- sapply(colnames(cluster.libs), function(x){
        if(! sum(cluster.libs[,x]) > 0) return(NA)
        if(any(cluster.libs[,x] == 0)){
            entropy <- -sum(cluster.libs[-which(cluster.libs[,x] == 0), x] * log2(cluster.libs[-which(cluster.libs[,x] == 0), x]))
        }else{
            entropy <- -sum(cluster.libs[, x] * log2(cluster.libs[, x]))
        }
        return(entropy)
    })

    cat("done\n")
    names(specific) <- colnames(cluster.libs)
    if(any(is.na(specific))){
    	specific <- specific[-which(is.na(specific))]
    }
    specific <- specific[which(specific <= summary(specific)[3])]
    cat(length(specific), " genes passed entropy threshold\n", sep = "")


    cat("testing for differential gene expression...\t")
    # implement testing with multtest for differentially expressed genes for each cluster
    # test each cluster against all other clusters at the same time
    if(normalize){
	    deg.counts <- normalize_counts(counts)
    }else{
	    deg.counts <- counts
    }
    test.results <- list()
    for(cl in rownames(cluster.libs)){
        # create temporary count matrix (transposed for multtest) and class labels
	    temp.counts <- t(deg.counts[c(which(clustering == cl),which(clustering != cl)),])
        labs <- c(rep(0,length(which(clustering == cl))), rep(1,length(which(clustering != cl))))
	    # calculate t-scores, p-values and adjust
        t.scores <- multtest::mt.teststat(temp.counts, labs, test = "t")
        p.vals <- 2 * pt(abs(t.scores), length(labs) - 2, lower.tail = FALSE)
        p.vals <- p.adjust(p.vals, method = "BH")
        names(p.vals) <- rownames(temp.counts)

        # if test not possible. set the genes p-value to 1 (max)
        if(any(is.na(p.vals))){
            p.vals[is.na(p.vals)] <- 1
        }
        if(any(is.nan(p.vals))){
            p.vals[is.nan(p.vals)] <- 1
        }
        p.vals <- sort(p.vals)
        test.results[[cl]] <- p.vals
    }
    cat("done\n")

    # right now all.genes is actually all genes, but if a significance cutoff
    # were used above, this would be needed
    all.genes <- as.vector(sapply(test.results, function(x){names(x)}))
    all.genes <- all.genes[!is.na(all.genes)]
    all.genes <- unique(all.genes)

    cat("Assign genes to clusters and remove insignificant genes...\t")
    # sort the clustering vector to have consistent order
    clusters <- sort(unique(clustering))
    # create a table with genes' p-value per cluster
    gene.table <- c()
    for(g in all.genes){
        cluster.values <- c()
        for(cl in clusters){
	    # if the gene is present in test results for the cluster add the value
	    # else add 1
            if(g %in% names(test.results[[cl]])){
                cluster.values <- c(cluster.values, as.numeric(test.results[[cl]][g]))
            }else{
                cluster.values <- c(cluster.values, 1)
            }
        }
        gene.table <- rbind(gene.table, cluster.values)
    }
    # create data frame with correct row- and colnames
    gene.table <- as.data.frame(gene.table)
    colnames(gene.table) <- clusters
    rownames(gene.table) <- all.genes
    for(cl in colnames(gene.table)){
	    gene.table[[cl]] <- as.numeric(as.character(gene.table[[cl]]))
    }

    # remove genes above significance threshold / with p-value NA in any cluster
    to.remove <- c()
    for(i in 1:nrow(gene.table)){
        if(min(gene.table[i,]) > sig.level | is.na(min(gene.table[i,]))){
            to.remove <- c(to.remove, i)
        }
    }
    if(length(to.remove) > 0){
        gene.table <- gene.table[-to.remove,]
    }
    # order table by minimum p-value for each gene
    gene.table <- gene.table[order(apply(as.matrix(gene.table), 1, min)),]
   
    # reduced information to minimum p-value, corresponding cluster, gene name and up/downregulation info
    gene.info <- c()
    for(i in 1:nrow(gene.table)){
        g <- rownames(gene.table)[i]
        p <- min(gene.table[i,])
  	
    # assign genes to downregulated clusters only if that p-value is less than 1 / ncluster of the
    # maximum upregulated value
    regulations <- sapply(clusters, function(cl){sign(mean(counts[which(clustering == cl),g]) - mean(counts[which(clustering != cl), g]))})
  	up.max <- max(gene.table[i,which(regulations > 0)])
  	down.max <- max(gene.table[i, which(regulations < 0)])
  	if(length(down.max) > 0 & length(up.max) > 0){
  		if(length(unique(clustering)) * down.max < up.max){
  			cl.which <- which(gene.table[i,] == down.max)
  			cl <- clusters[intersect(which(regulations < 0), cl.which)]
  		}else{
  			cl.which <- which(gene.table[i,] == up.max)
  			cl <- clusters[intersect(which(regulations > 0), cl.which)]
  		}
  	}else{
          	cl <- clusters[which.min(gene.table[i,])]
  	}
  	if(length(cl) > 0){
  		# up-/downregulation
          	reg <- sign(mean(counts[which(clustering == cl),g]) - mean(counts[which(clustering != cl), g]))
          	gene.info <- rbind(gene.info,
                  	           c(g, cl, p, reg))
  	}
    }
    gene.info <- as.data.frame(gene.info)
    colnames(gene.info) <- c("gene", "cluster", "pVal", "regulation")
    gene.info$pVal <- as.numeric(as.character(gene.info$pVal))
    gene.info$regulation <- as.numeric(as.character(gene.info$regulation))
    rownames(gene.info) <- as.character(gene.info$gene)

    cat("done\n")
    cat(nrow(gene.info), " genes passed the significance threshold\n", sep = "")
    gene.info <- filter_genes(gene.info, specific, lasso.data, deg.weight = deg.weight, lls.weight = lls.weight, entropy.weight = entropy.weight, build.lasso = build.lasso, ncores = ncores, gamma = gamma, counts = counts, ids = ids)

    return(list(
        differential_genes = gene.info,
        gene.cluster.table = gene.table[rownames(gene.info),]
	))
}
