#' cluster spots using enrichment analysis, kmeans and hierarchical clustering
#' 
#' @param counts non-negative numeric matrix. rows correspond to spots, 
#' columns correspond to genes
#' @param spot.enrichments list with two entries as returned by calculate_spot_enrichments(): \cr
#' 1) enrichment.list: list containing an enrichment table for each spot in the count matrix\cr
#' 2) term.matrix: numeric matrix, terms x spots containing the p-value for each term in each spot
#' @param term.cutoff numeric > 0, minimum number of spots a term needs to be enriched in in order to be
#' considered in the analysis
#' @param spot.cutoff numeric > 0, minimum number of terms that have to be enriched in a spot for it be
#' considered in the analysis
#' @param n.cluster.spots numeric > 0, number of clusters the spots should be grouped in
#' @param n.cluster.terms numeric > 0, number of clusters the terms should be grouped in
#' @param ncores number of threads to be used for parallel execution
#' @param verbose logical
#' @param output_folder string specifying the directory in which plots generated by this function should be stored; default NULL, no plots generated
#' @param method string specifying the clustering method to be used. default: 'normal'
#' @return list containing five elements\cr
#' 1) spot.enrichments: list as returned by calculate_spot_enrichments()\cr
#' 2) enrichment.mat: numeric matrix, terms x spots containing the p-value for each term in each spot\cr
#' 3) spot.clustering: clustering information for spots in enrichment.mat
#' 4) term.clustering: clustering information for terms in enrichment.mat
#' 5) term.clusters: list containing for each term cluster a vector of terms belonging to that cluster
#' @export

cluster_spots <- function(counts, spot.enrichments = NULL, term.cutoff = 10, spot.cutoff = 1, n.cluster.spots = 6, n.cluster.terms = 6, n.cores = 4, verbose = TRUE, output_folder = NULL, method = 'normal'){
    if(is.null(spot.enrichments)){
        if(verbose) print("calculating spot enrichments")
        tic("enrichment calculation")
        spot.enrichments <- calculate_spot_enrichments(counts, n.cores = n.cores)
        toc()
    }
    enrichment.mat <- spot.enrichments$term.matrix
    enrichment.list <- spot.enrichments$enrichment.list
    if(!is.null(output_folder)){
        pdf(paste(output_folder,"term_mat_infos.pdf", sep = "/"))
        hist(as.vector(enrichment.mat[enrichment.mat < 1]), breaks = 1000, main = "distribution of enrichment p-values", xlab = "p-value")
        hist(apply(enrichment.mat, 2, function(x){sum(x != 1)}), breaks = 50, main = "distribution of number of enriched terms per spot", xlab = "enriched terms")
        hist(apply(enrichment.mat, 1, function(x){sum(x != 1)}), breaks = 50, main = "distribution of number of spots in which a term is enriched", xlab = "enriched spots")
        dev.off()
    }

    # use a binary approach to enrichment
    enrichment.mat[enrichment.mat == 1] <- 0
    enrichment.mat[enrichment.mat > 0] <- 1
    if(any(rowSums(enrichment.mat) < term.cutoff)){
        enrichment.mat <- enrichment.mat[-which(rowSums(enrichment.mat) < term.cutoff), ]
    }
    if(any(colSums(enrichment.mat) < spot.cutoff)){
        enrichment.mat <- enrichment.mat[, -which(colSums(enrichment.mat) < spot.cutoff)]
    }
    if(verbose) print(dim(enrichment.mat))

    print("Clustering spots...")
    #if(method == 'normal'){
    d <- get_dist(t(enrichment.mat), "manhattan")
    tree <- hclust(d, "complete")
    # order by clustering for better visualization later on
    enrichment.mat <- enrichment.mat[, tree$order]

    # k-means worked best in most cases
    clustering <- kmeans(t(enrichment.mat), n.cluster.spots)$cluster
    enrichment.mat <- enrichment.mat[, order(clustering)]
    clustering <- sort(clustering)
    # }else{
    #     if(method == 'ol'){
    #         # cluster based on orderedList
    #         ol.cluster <- cluster_ol(spot.enrichments$term.matrix[, colnames(enrichment.mat)], k = n.cluster.spots)
    #         clustering <- ol.cluster$clustering
    #         enrichment.mat <- enrichment.mat[, ol.cluster$order]
    #     }
    #     if(method == 'own'){
    #         d <- get_dist(t(enrichment.mat), "manhattan")
    #         tree <- hclust(d, "single")
    #         # order by clustering for better visualization later on
    #         enrichment.mat <- enrichment.mat[, tree$order]

    #         clustering <- clustering_own(enrichment.mat, k = n.cluster.spots)
    #         enrichment.mat <- enrichment.mat[, order(clustering)]
    #         clustering <- sort(clustering)
    #     }
    # }

    print("Filtering terms based on clustering...")
    # reduce number of terms based on this clustering
    enrichment.mat <- reduce_term_mat(enrichment.mat, clustering)

    # test the signatures using zeroSum
    #zs_classes <- zerosum_check(enrichment.mat, clustering)
    
    print("Clustering Terms...")
    if(method == 'normal'){
         term.dist <- get_dist(enrichment.mat, "manhattan")
         term.tree <- hclust(term.dist, "complete")

         term.clust <- cutree(term.tree, k = n.cluster.terms)
         term.clust <- term.clust[term.tree$order]
         enrichment.mat <- enrichment.mat[term.tree$order,]
     }

    term.clusters <- list()
    for(i in unique(term.clust)){
        term.clusters[[as.character(i)]] <- rownames(enrichment.mat)[which(term.clust == i)]
    }

    return(list(spot.enrichments = spot.enrichments,
                enrichment.mat = enrichment.mat,
                spot.clustering = clustering,
                term.clustering = term.clust,
                term.clusters = term.clusters
                )
    )
}